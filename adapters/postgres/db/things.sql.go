// Code generated by sqlc. DO NOT EDIT.
// source: things.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createThing = `-- name: CreateThing :one
INSERT INTO things (
  id, code, name
) VALUES (
  $1, $2, $3
)
RETURNING id, code, name
`

type CreateThingParams struct {
	ID   int32     `json:"id"`
	Code uuid.UUID `json:"code"`
	Name string    `json:"name"`
}

func (q *Queries) CreateThing(ctx context.Context, arg CreateThingParams) (Thing, error) {
	row := q.queryRow(ctx, q.createThingStmt, createThing, arg.ID, arg.Code, arg.Name)
	var i Thing
	err := row.Scan(&i.ID, &i.Code, &i.Name)
	return i, err
}

const deleteThing = `-- name: DeleteThing :exec
DELETE 
  FROM things
 WHERE id = $1
`

func (q *Queries) DeleteThing(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteThingStmt, deleteThing, id)
	return err
}

const deleteThingByCode = `-- name: DeleteThingByCode :exec
DELETE 
  FROM things
 WHERE code = $1
`

func (q *Queries) DeleteThingByCode(ctx context.Context, code uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteThingByCodeStmt, deleteThingByCode, code)
	return err
}

const getThing = `-- name: GetThing :one
SELECT id, code, name 
  FROM things t
WHERE t.id = $1
LIMIT 1
`

func (q *Queries) GetThing(ctx context.Context, id int32) (Thing, error) {
	row := q.queryRow(ctx, q.getThingStmt, getThing, id)
	var i Thing
	err := row.Scan(&i.ID, &i.Code, &i.Name)
	return i, err
}

const getThingByCode = `-- name: GetThingByCode :one
SELECT id, code, name 
  FROM things t
WHERE t.code = $1
LIMIT 1
`

func (q *Queries) GetThingByCode(ctx context.Context, code uuid.UUID) (Thing, error) {
	row := q.queryRow(ctx, q.getThingByCodeStmt, getThingByCode, code)
	var i Thing
	err := row.Scan(&i.ID, &i.Code, &i.Name)
	return i, err
}

const listThings = `-- name: ListThings :many
SELECT id, code, name
  FROM things t
 ORDER BY t.name
`

func (q *Queries) ListThings(ctx context.Context) ([]Thing, error) {
	rows, err := q.query(ctx, q.listThingsStmt, listThings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thing
	for rows.Next() {
		var i Thing
		if err := rows.Scan(&i.ID, &i.Code, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateThing = `-- name: UpdateThing :one
UPDATE things
   SET code = $2
     , name = $3
 WHERE id = $1
 RETURNING id, code, name
`

type UpdateThingParams struct {
	ID   int32     `json:"id"`
	Code uuid.UUID `json:"code"`
	Name string    `json:"name"`
}

func (q *Queries) UpdateThing(ctx context.Context, arg UpdateThingParams) (Thing, error) {
	row := q.queryRow(ctx, q.updateThingStmt, updateThing, arg.ID, arg.Code, arg.Name)
	var i Thing
	err := row.Scan(&i.ID, &i.Code, &i.Name)
	return i, err
}
